#include <stdio.h>
#include <stdlib.h>
#include <elf.h>
#include <string.h>

// função basica para ler o elf_header de um arquivo especifico
void elf_header(const char *filename, Elf64_Ehdr *header) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    // lendo o elf_header do arquivo
    if (fread(header, 1, sizeof(*header), file) != sizeof(*header)) {
        perror("fread");
        fclose(file);
        exit(EXIT_FAILURE); 
    }

    // verificando se é um elf valido com o e_ident da identificação da estrutura certa do elf
    if (header->e_ident[EI_MAG0] != ELFMAG0 ||
        header->e_ident[EI_MAG1] != ELFMAG1 ||
        header->e_ident[EI_MAG2] != ELFMAG2 ||
        header->e_ident[EI_MAG3] != ELFMAG3) {
            fprintf(stderr, "[!] não é um arquivo ELF\n");
            fclose(file);
            exit(EXIT_FAILURE);
        }

    printf("[+] elf_header: leitura com sucesso!\n");
    fclose(file);
}     

// função pra ler a section .text do ELF
void rtext_section(const char *filename, Elf64_Ehdr *header) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    // movendo pra tabela de headers de seção
    fseek(file, header->e_shoff, SEEK_SET);

    Elf64_Shdr *section_headers = malloc(header->e_shnum * sizeof(Elf64_Shdr));
    if (fread(section_headers, header->e_shnum, sizeof(Elf64_Shdr), file) != sizeof(Elf64_Shdr) * header->e_shnum) {
        perror("fread");
        fclose(file);
        exit(EXIT_FAILURE);
    }

    // encontrando seções de texto...
    for (int i = 0; i < header->e_shnum; i++) {
        if (section_headers[i].sh_type == SHT_PROGBITS && section_headers[i].sh_flags & SHF_EXECINSTR) {
            // alocar memória para a section .text
            uint8_t *text_section = malloc(section_headers[i].sh_size);
            fseek(file, section_headers[i].sh_offset, SEEK_SET);
            if (fread(text_section, 1, section_headers[i].sh_size, file) != section_headers[i].sh_size) {
                perror("fread");
                fclose(file);
                exit(EXIT_FAILURE);
            }

            for(size_t j = 0; j < section_headers[i].sh_size; j++) {
                if (text_section[j] == 0xC3) { // 0xc3 é o opcode 'ret'
                    printf("[+] gadget encontrado no offset: 0x%lx\n", section_headers[j].sh_addr + j);

                    // verificando instruções antes de ret (gadgets de até 10 instruções/modos)
                    for (int k = 1; k <= 10 && j >= k; k++) {
                        printf("[+] possivel gadget de %d modos encontrado no offset: 0x%lx\n", k, section_headers[i].sh_addr + j - k);
                    }
                }
            }

            free(text_section);
        }
    }

    free(section_headers);
    fclose(file);
}

int main(int argc, char **argv) {
    printf("   version 1.0\n   elf-gadger\n\n");
    // verificando se o numero de argumentos está realmente correto
    if (argc != 2) {
        fprintf(stderr, "usages : %s <elf-file>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    Elf64_Ehdr header; // Declarar a variável header
    elf_header(argv[1], &header); // chama a função para ler o elf_header
    rtext_section(argv[1], &header); // chamando para ler seções de texto, alocar em memória e percorrer os gadgets

    return 0;
}
