#include <stdio.h>
#include <stdlib.h>
#include <elf.h>
#include <string.h>

// função básica para ler o elf_header de um arquivo específico
void elf_header(const char *filename, Elf64_Ehdr *header) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    // lendo o elf_header do arquivo
    if (fread(header, 1, sizeof(*header), file) != sizeof(*header)) {
        perror("fread");
        fclose(file);
        exit(EXIT_FAILURE); 
    }

    // verificando se é um ELF válido com o e_ident da identificação da estrutura certa do ELF
    if (header->e_ident[EI_MAG0] != ELFMAG0 ||
        header->e_ident[EI_MAG1] != ELFMAG1 ||
        header->e_ident[EI_MAG2] != ELFMAG2 ||
        header->e_ident[EI_MAG3] != ELFMAG3) {
            fprintf(stderr, "[!] não é um arquivo ELF\n");
            fclose(file);
            exit(EXIT_FAILURE);
        }

    printf("[+] elf_header: leitura com sucesso!\n");
    fclose(file);
}     

// função pra ler a seção .text do ELF
void rtext_section(const char *filename, Elf64_Ehdr *header) {
    FILE *file = fopen(filename, "rb");
    if (!file) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    // movendo pra tabela de headers de seção
    fseek(file, header->e_shoff, SEEK_SET);

    Elf64_Shdr *section_headers = malloc(header->e_shnum * sizeof(Elf64_Shdr));
    if (!section_headers) {
        perror("malloc");
        fclose(file);
        exit(EXIT_FAILURE);
    }

    if (fread(section_headers, sizeof(Elf64_Shdr), header->e_shnum, file) != header->e_shnum) {
        perror("fread");
        free(section_headers);
        fclose(file);
        exit(EXIT_FAILURE);
    }

    // encontrando seções de texto...
    for (int i = 0; i < header->e_shnum; i++) {
        if (section_headers[i].sh_type == SHT_PROGBITS && section_headers[i].sh_flags & SHF_EXECINSTR) {
            printf("[+] Seção .text encontrada no índice: %d\n", i);
	    // printf("-----------------------------------------------");
            printf("[+] Tamanho da seção: .text: 0x%lx\n", section_headers[i].sh_size);
            // printf("-----------------------------------------------");
            printf("[+] Offset da seção: .text: 0x%lx\n", section_headers[i].sh_offset);
	    // printf("-----------------------------------------------");
            // alocar memória para a seção .text
            uint8_t *text_section = malloc(section_headers[i].sh_size);
            if (!text_section) {
                perror("malloc");
                free(section_headers);
                fclose(file);
                exit(EXIT_FAILURE);
            }

            fseek(file, section_headers[i].sh_offset, SEEK_SET);
            if (fread(text_section, 1, section_headers[i].sh_size, file) != section_headers[i].sh_size) {
                perror("fread");
                free(text_section);
                free(section_headers);
                fclose(file);
                exit(EXIT_FAILURE);
            }

            for(size_t j = 0; j < section_headers[i].sh_size; j++) {
                if (text_section[j] == 0xC3) { // 0xc3 é o opcode 'ret'
                    printf("[+] Gadget encontrado no offset: 0x%lx\n--------------\n", section_headers[i].sh_addr + j);
		    // printf("-----------------------------------------------");

                    // verificando instruções antes de ret (gadgets de até 10 instruções/modos)
                    for (int k = 1; k <= 10 && j >= k; k++) {
                        printf("[+] Possível gadget de %d modos encontrado no offset: 0x%lx\n", k, section_headers[i].sh_addr + j - k);
                       // printf("-----------------------------------------------");
                    }
                }
            }

            free(text_section);
        }
    }

    free(section_headers);
    fclose(file);
}

int main(int argc, char **argv) {
    printf("   version 1.0\n   elf-gadger\n\n");
    // verificando se o número de argumentos está realmente correto
    if (argc != 2) {
        fprintf(stderr, "usages: %s <arquivo-elf>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    Elf64_Ehdr header; // Declarar a variável header
    elf_header(argv[1], &header); // chama a função para ler o elf_header
    rtext_section(argv[1], &header); //lê as seções de texto e aloca na memória para percorrer os gadgets

    return 0;
}
